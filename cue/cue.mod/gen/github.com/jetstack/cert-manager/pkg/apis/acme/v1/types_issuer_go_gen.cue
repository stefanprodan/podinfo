// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/jetstack/cert-manager/pkg/apis/acme/v1

package v1

import (
	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

// ACMEIssuer contains the specification for an ACME issuer.
// This uses the RFC8555 specification to obtain certificates by completing
// 'challenges' to prove ownership of domain identifiers.
// Earlier draft versions of the ACME specification are not supported.
#ACMEIssuer: {
	// Email is the email address to be associated with the ACME account.
	// This field is optional, but it is strongly recommended to be set.
	// It will be used to contact you in case of issues with your account or
	// certificates, including expiry notification emails.
	// This field may be updated after the account is initially registered.
	// +optional
	email?: string @go(Email)

	// Server is the URL used to access the ACME server's 'directory' endpoint.
	// For example, for Let's Encrypt's staging endpoint, you would use:
	// "https://acme-staging-v02.api.letsencrypt.org/directory".
	// Only ACME v2 endpoints (i.e. RFC 8555) are supported.
	server: string @go(Server)

	// PreferredChain is the chain to use if the ACME server outputs multiple.
	// PreferredChain is no guarantee that this one gets delivered by the ACME
	// endpoint.
	// For example, for Let's Encrypt's DST crosssign you would use:
	// "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
	// This value picks the first certificate bundle in the ACME alternative
	// chains that has a certificate with this value as its issuer's CN
	// +optional
	// +kubebuilder:validation:MaxLength=64
	preferredChain: string @go(PreferredChain)

	// Enables or disables validation of the ACME server TLS certificate.
	// If true, requests to the ACME server will not have their TLS certificate
	// validated (i.e. insecure connections will be allowed).
	// Only enable this option in development environments.
	// The cert-manager system installed roots will be used to verify connections
	// to the ACME server if this is false.
	// Defaults to false.
	// +optional
	skipTLSVerify?: bool @go(SkipTLSVerify)

	// ExternalAccountBinding is a reference to a CA external account of the ACME
	// server.
	// If set, upon registration cert-manager will attempt to associate the given
	// external account credentials with the registered ACME account.
	// +optional
	externalAccountBinding?: null | #ACMEExternalAccountBinding @go(ExternalAccountBinding,*ACMEExternalAccountBinding)

	// PrivateKey is the name of a Kubernetes Secret resource that will be used to
	// store the automatically generated ACME account private key.
	// Optionally, a `key` may be specified to select a specific entry within
	// the named Secret resource.
	// If `key` is not specified, a default of `tls.key` will be used.
	privateKeySecretRef: cmmeta.#SecretKeySelector @go(PrivateKey)

	// Solvers is a list of challenge solvers that will be used to solve
	// ACME challenges for the matching domains.
	// Solver configurations must be provided in order to obtain certificates
	// from an ACME server.
	// For more information, see: https://cert-manager.io/docs/configuration/acme/
	// +optional
	solvers?: [...#ACMEChallengeSolver] @go(Solvers,[]ACMEChallengeSolver)

	// Enables or disables generating a new ACME account key.
	// If true, the Issuer resource will *not* request a new account but will expect
	// the account key to be supplied via an existing secret.
	// If false, the cert-manager system will generate a new ACME account key
	// for the Issuer.
	// Defaults to false.
	// +optional
	disableAccountKeyGeneration?: bool @go(DisableAccountKeyGeneration)

	// Enables requesting a Not After date on certificates that matches the
	// duration of the certificate. This is not supported by all ACME servers
	// like Let's Encrypt. If set to true when the ACME server does not support
	// it it will create an error on the Order.
	// Defaults to false.
	// +optional
	enableDurationFeature?: bool @go(EnableDurationFeature)
}

// ACMEExternalAccountBinding is a reference to a CA external account of the ACME
// server.
#ACMEExternalAccountBinding: {
	// keyID is the ID of the CA key that the External Account is bound to.
	keyID: string @go(KeyID)

	// keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
	// Secret which holds the symmetric MAC key of the External Account Binding.
	// The `key` is the index string that is paired with the key data in the
	// Secret and should not be confused with the key data itself, or indeed with
	// the External Account Binding keyID above.
	// The secret key stored in the Secret **must** be un-padded, base64 URL
	// encoded data.
	keySecretRef: cmmeta.#SecretKeySelector @go(Key)

	// Deprecated: keyAlgorithm field exists for historical compatibility
	// reasons and should not be used. The algorithm is now hardcoded to HS256
	// in golang/x/crypto/acme.
	// +optional
	keyAlgorithm?: #HMACKeyAlgorithm @go(KeyAlgorithm)
}

// HMACKeyAlgorithm is the name of a key algorithm used for HMAC encryption
// +kubebuilder:validation:Enum=HS256;HS384;HS512
#HMACKeyAlgorithm: string // #enumHMACKeyAlgorithm

#enumHMACKeyAlgorithm:
	#HS256 |
	#HS384 |
	#HS512

#HS256: #HMACKeyAlgorithm & "HS256"
#HS384: #HMACKeyAlgorithm & "HS384"
#HS512: #HMACKeyAlgorithm & "HS512"

// An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of.
// A selector may be provided to use different solving strategies for different DNS names.
// Only one of HTTP01 or DNS01 must be provided.
#ACMEChallengeSolver: {
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	// +optional
	selector?: null | #CertificateDNSNameSelector @go(Selector,*CertificateDNSNameSelector)

	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	// +optional
	http01?: null | #ACMEChallengeSolverHTTP01 @go(HTTP01,*ACMEChallengeSolverHTTP01)

	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	// +optional
	dns01?: null | #ACMEChallengeSolverDNS01 @go(DNS01,*ACMEChallengeSolverDNS01)
}

// CertificateDNSNameSelector selects certificates using a label selector, and
// can optionally select individual DNS names within those certificates.
// If both MatchLabels and DNSNames are empty, this selector will match all
// certificates and DNS names within them.
#CertificateDNSNameSelector: {
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	// +optional
	matchLabels?: {[string]: string} @go(MatchLabels,map[string]string)

	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	// +optional
	dnsNames?: [...string] @go(DNSNames,[]string)

	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	// +optional
	dnsZones?: [...string] @go(DNSZones,[]string)
}

// ACMEChallengeSolverHTTP01 contains configuration detailing how to solve
// HTTP01 challenges within a Kubernetes cluster.
// Typically this is accomplished through creating 'routes' of some description
// that configure ingress controllers to direct traffic to 'solver pods', which
// are responsible for responding to the ACME server's HTTP requests.
// Only one of Ingress / Gateway can be specified.
#ACMEChallengeSolverHTTP01: {
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	// +optional
	ingress?: null | #ACMEChallengeSolverHTTP01Ingress @go(Ingress,*ACMEChallengeSolverHTTP01Ingress)

	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	// +optional
	gatewayHTTPRoute?: null | #ACMEChallengeSolverHTTP01GatewayHTTPRoute @go(GatewayHTTPRoute,*ACMEChallengeSolverHTTP01GatewayHTTPRoute)
}

#ACMEChallengeSolverHTTP01Ingress: {
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	// +optional
	serviceType?: corev1.#ServiceType @go(ServiceType)

	// The ingress class to use when creating Ingress resources to solve ACME
	// challenges that use this challenge solver.
	// Only one of 'class' or 'name' may be specified.
	// +optional
	class?: null | string @go(Class,*string)

	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources.
	// +optional
	name?: string @go(Name)

	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	// +optional
	podTemplate?: null | #ACMEChallengeSolverHTTP01IngressPodTemplate @go(PodTemplate,*ACMEChallengeSolverHTTP01IngressPodTemplate)

	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	// +optional
	ingressTemplate?: null | #ACMEChallengeSolverHTTP01IngressTemplate @go(IngressTemplate,*ACMEChallengeSolverHTTP01IngressTemplate)
}

// The ACMEChallengeSolverHTTP01GatewayHTTPRoute solver will create HTTPRoute objects for a Gateway class
// routing to an ACME challenge solver pod.
#ACMEChallengeSolverHTTP01GatewayHTTPRoute: {
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	// +optional
	serviceType?: corev1.#ServiceType @go(ServiceType)

	// The labels that cert-manager will use when creating the temporary
	// HTTPRoute needed for solving the HTTP-01 challenge. These labels
	// must match the label selector of at least one Gateway.
	labels?: {[string]: string} @go(Labels,map[string]string)
}

#ACMEChallengeSolverHTTP01IngressPodTemplate: {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	// +optional
	metadata: #ACMEChallengeSolverHTTP01IngressPodObjectMeta @go(ACMEChallengeSolverHTTP01IngressPodObjectMeta)

	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Only the 'priorityClassName', 'nodeSelector', 'affinity',
	// 'serviceAccountName' and 'tolerations' fields are supported currently.
	// All other fields will be ignored.
	// +optional
	spec: #ACMEChallengeSolverHTTP01IngressPodSpec @go(Spec)
}

#ACMEChallengeSolverHTTP01IngressPodObjectMeta: {
	// Annotations that should be added to the create ACME HTTP01 solver pods.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Labels that should be added to the created ACME HTTP01 solver pods.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

#ACMEChallengeSolverHTTP01IngressPodSpec: {
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// If specified, the pod's scheduling constraints
	// +optional
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// If specified, the pod's tolerations.
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// If specified, the pod's priorityClassName.
	// +optional
	priorityClassName?: string @go(PriorityClassName)

	// If specified, the pod's service account
	// +optional
	serviceAccountName?: string @go(ServiceAccountName)
}

#ACMEChallengeSolverHTTP01IngressTemplate: {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	// +optional
	metadata: #ACMEChallengeSolverHTTP01IngressObjectMeta @go(ACMEChallengeSolverHTTP01IngressObjectMeta)
}

#ACMEChallengeSolverHTTP01IngressObjectMeta: {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Labels that should be added to the created ACME HTTP01 solver ingress.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

// Used to configure a DNS01 challenge provider to be used when solving DNS01
// challenges.
// Only one DNS provider may be configured per solver.
#ACMEChallengeSolverDNS01: {
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	// +optional
	cnameStrategy?: #CNAMEStrategy @go(CNAMEStrategy)

	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	// +optional
	akamai?: null | #ACMEIssuerDNS01ProviderAkamai @go(Akamai,*ACMEIssuerDNS01ProviderAkamai)

	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	// +optional
	cloudDNS?: null | #ACMEIssuerDNS01ProviderCloudDNS @go(CloudDNS,*ACMEIssuerDNS01ProviderCloudDNS)

	// Use the Cloudflare API to manage DNS01 challenge records.
	// +optional
	cloudflare?: null | #ACMEIssuerDNS01ProviderCloudflare @go(Cloudflare,*ACMEIssuerDNS01ProviderCloudflare)

	// Use the AWS Route53 API to manage DNS01 challenge records.
	// +optional
	route53?: null | #ACMEIssuerDNS01ProviderRoute53 @go(Route53,*ACMEIssuerDNS01ProviderRoute53)

	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	// +optional
	azureDNS?: null | #ACMEIssuerDNS01ProviderAzureDNS @go(AzureDNS,*ACMEIssuerDNS01ProviderAzureDNS)

	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	// +optional
	digitalocean?: null | #ACMEIssuerDNS01ProviderDigitalOcean @go(DigitalOcean,*ACMEIssuerDNS01ProviderDigitalOcean)

	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	// +optional
	acmeDNS?: null | #ACMEIssuerDNS01ProviderAcmeDNS @go(AcmeDNS,*ACMEIssuerDNS01ProviderAcmeDNS)

	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	// +optional
	rfc2136?: null | #ACMEIssuerDNS01ProviderRFC2136 @go(RFC2136,*ACMEIssuerDNS01ProviderRFC2136)

	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	// +optional
	webhook?: null | #ACMEIssuerDNS01ProviderWebhook @go(Webhook,*ACMEIssuerDNS01ProviderWebhook)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME records
// when found in DNS zones.
// By default, the None strategy will be applied (i.e. do not follow CNAMEs).
// +kubebuilder:validation:Enum=None;Follow
#CNAMEStrategy: string

// NoneStrategy indicates that no CNAME resolution strategy should be used
// when determining which DNS zone to update during DNS01 challenges.
#NoneStrategy: "None"

// FollowStrategy will cause cert-manager to recurse through CNAMEs in
// order to determine which DNS zone to update during DNS01 challenges.
// This is useful if you do not want to grant cert-manager access to your
// root DNS zone, and instead delegate the _acme-challenge.example.com
// subdomain to some other, less privileged domain.
#FollowStrategy: "Follow"

// ACMEIssuerDNS01ProviderAkamai is a structure containing the DNS
// configuration for Akamai DNS—Zone Record Management API
#ACMEIssuerDNS01ProviderAkamai: {
	serviceConsumerDomain: string                    @go(ServiceConsumerDomain)
	clientTokenSecretRef:  cmmeta.#SecretKeySelector @go(ClientToken)
	clientSecretSecretRef: cmmeta.#SecretKeySelector @go(ClientSecret)
	accessTokenSecretRef:  cmmeta.#SecretKeySelector @go(AccessToken)
}

// ACMEIssuerDNS01ProviderCloudDNS is a structure containing the DNS
// configuration for Google Cloud DNS
#ACMEIssuerDNS01ProviderCloudDNS: {
	// +optional
	serviceAccountSecretRef?: null | cmmeta.#SecretKeySelector @go(ServiceAccount,*cmmeta.SecretKeySelector)
	project:                  string                           @go(Project)

	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	// +optional
	hostedZoneName?: string @go(HostedZoneName)
}

// ACMEIssuerDNS01ProviderCloudflare is a structure containing the DNS
// configuration for Cloudflare.
// One of `apiKeySecretRef` or `apiTokenSecretRef` must be provided.
#ACMEIssuerDNS01ProviderCloudflare: {
	// Email of the account, only required when using API key based authentication.
	// +optional
	email?: string @go(Email)

	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	// +optional
	apiKeySecretRef?: null | cmmeta.#SecretKeySelector @go(APIKey,*cmmeta.SecretKeySelector)

	// API token used to authenticate with Cloudflare.
	// +optional
	apiTokenSecretRef?: null | cmmeta.#SecretKeySelector @go(APIToken,*cmmeta.SecretKeySelector)
}

// ACMEIssuerDNS01ProviderDigitalOcean is a structure containing the DNS
// configuration for DigitalOcean Domains
#ACMEIssuerDNS01ProviderDigitalOcean: {
	tokenSecretRef: cmmeta.#SecretKeySelector @go(Token)
}

// ACMEIssuerDNS01ProviderRoute53 is a structure containing the Route 53
// configuration for AWS
#ACMEIssuerDNS01ProviderRoute53: {
	// The AccessKeyID is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	// +optional
	accessKeyID?: string @go(AccessKeyID)

	// The SecretAccessKey is used for authentication. If not set we fall-back to using env vars, shared credentials file or AWS Instance metadata
	// https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	// +optional
	secretAccessKeySecretRef: cmmeta.#SecretKeySelector @go(SecretAccessKey)

	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	// +optional
	role?: string @go(Role)

	// If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call.
	// +optional
	hostedZoneID?: string @go(HostedZoneID)

	// Always set the region when using AccessKeyID and SecretAccessKey
	region: string @go(Region)
}

// ACMEIssuerDNS01ProviderAzureDNS is a structure containing the
// configuration for Azure DNS
#ACMEIssuerDNS01ProviderAzureDNS: {
	// if both this and ClientSecret are left unset MSI will be used
	// +optional
	clientID?: string @go(ClientID)

	// if both this and ClientID are left unset MSI will be used
	// +optional
	clientSecretSecretRef?: null | cmmeta.#SecretKeySelector @go(ClientSecret,*cmmeta.SecretKeySelector)

	// ID of the Azure subscription
	subscriptionID: string @go(SubscriptionID)

	// when specifying ClientID and ClientSecret then this field is also needed
	// +optional
	tenantID?: string @go(TenantID)

	// resource group the DNS zone is located in
	resourceGroupName: string @go(ResourceGroupName)

	// name of the DNS zone that should be used
	// +optional
	hostedZoneName?: string @go(HostedZoneName)

	// name of the Azure environment (default AzurePublicCloud)
	// +optional
	environment?: #AzureDNSEnvironment @go(Environment)

	// managed identity configuration, can not be used at the same time as clientID, clientSecretSecretRef or tenantID
	// +optional
	managedIdentity?: null | #AzureManagedIdentity @go(ManagedIdentity,*AzureManagedIdentity)
}

#AzureManagedIdentity: {
	// client ID of the managed identity, can not be used at the same time as resourceID
	// +optional
	clientID?: string @go(ClientID)

	// resource ID of the managed identity, can not be used at the same time as clientID
	// +optional
	resourceID?: string @go(ResourceID)
}

// +kubebuilder:validation:Enum=AzurePublicCloud;AzureChinaCloud;AzureGermanCloud;AzureUSGovernmentCloud
#AzureDNSEnvironment: string // #enumAzureDNSEnvironment

#enumAzureDNSEnvironment:
	#AzurePublicCloud |
	#AzureChinaCloud |
	#AzureGermanCloud |
	#AzureUSGovernmentCloud

#AzurePublicCloud:       #AzureDNSEnvironment & "AzurePublicCloud"
#AzureChinaCloud:        #AzureDNSEnvironment & "AzureChinaCloud"
#AzureGermanCloud:       #AzureDNSEnvironment & "AzureGermanCloud"
#AzureUSGovernmentCloud: #AzureDNSEnvironment & "AzureUSGovernmentCloud"

// ACMEIssuerDNS01ProviderAcmeDNS is a structure containing the
// configuration for ACME-DNS servers
#ACMEIssuerDNS01ProviderAcmeDNS: {
	host:             string                    @go(Host)
	accountSecretRef: cmmeta.#SecretKeySelector @go(AccountSecret)
}

// ACMEIssuerDNS01ProviderRFC2136 is a structure containing the
// configuration for RFC2136 DNS
#ACMEIssuerDNS01ProviderRFC2136: {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	nameserver: string @go(Nameserver)

	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	// +optional
	tsigSecretSecretRef?: cmmeta.#SecretKeySelector @go(TSIGSecret)

	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	// +optional
	tsigKeyName?: string @go(TSIGKeyName)

	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	// +optional
	tsigAlgorithm?: string @go(TSIGAlgorithm)
}

// ACMEIssuerDNS01ProviderWebhook specifies configuration for a webhook DNS01
// provider, including where to POST ChallengePayload resources.
#ACMEIssuerDNS01ProviderWebhook: {
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	groupName: string @go(GroupName)

	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	solverName: string @go(SolverName)

	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	// +optional
	config?: null | apiextensionsv1.#JSON @go(Config,*apiextensionsv1.JSON)
}

#ACMEIssuerStatus: {
	// URI is the unique account identifier, which can also be used to retrieve
	// account details from the CA
	// +optional
	uri?: string @go(URI)

	// LastRegisteredEmail is the email associated with the latest registered
	// ACME account, in order to track changes made to registered account
	// associated with the  Issuer
	// +optional
	lastRegisteredEmail?: string @go(LastRegisteredEmail)
}
